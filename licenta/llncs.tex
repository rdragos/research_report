\documentclass[12pt]{book}
\usepackage{amsmath, amsthm, amssymb, url,graphicx}
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{llncsdoc}
\usepackage{algorithmic}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{cite}
\usepackage{amsmath}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[parfill]{parskip} 
\usepackage{float}
\usepackage{caption}
\usepackage[utf8]{inputenc}
\usepackage{combelow}% provides \cb to place comma below character

\usepackage{newunicodechar}
\newunicodechar{ș}{\cb{s}}
\newunicodechar{ț}{\cb{t}}

\newunicodechar{Ș}{\cb{S}}
\newunicodechar{Ț}{\cb{S}}

\title{Protocale Criptografice de Grup}
\author{Dragoș Alin Rotaru}
\date{2015}

\renewcommand{\chaptername}{Capitolul}
\renewcommand\contentsname{Cuprins}

\newcommand{\Mod}[1]{\ (\text{mod}\ #1)}
\newcommand{\todo}[1]{{\color{red}{TODO #1}}}

\newtheorem{implicatie}{\textbf{Implicața}}[section]
\newtheorem{observatie}{\textbf{Observația}}[section]
\newtheorem{definitie}{\textbf{Definiția}}[section]
\newtheorem{teorema}{\textbf{Teorema}}[section]
\newtheorem{lema}{\textbf{Lema}}[section]
%\def\examplename{Exemplul}

\newtheorem{exemplu}{\textbf{Exemplu}}[section]
 
\begin{document}
%  de titlu
\thispagestyle{empty}

\centerline{\bf UNIVERSITATEA BUCUREȘTI}

\centerline{\bf FACULTATEA DE MATEMATICĂ ȘI INFORMATICĂ}

\vspace{4.5cm}

\centerline{\huge \bf Protocoale Criptografice de Grup}

\vspace{0.5cm}

\centerline{\large \bf Lucrare de Licență}

\vspace{3.5cm}

\begin{flushleft}
{\Large \textit{Coordonator:}\vspace{0.2cm}}

{\Large Lect.dr. Ruxandra F. Olimid}
\end{flushleft}

\vspace{1cm}
\begin{flushright}
{\Large \textit{Student:}\vspace{0.2cm}}

{\Large Dragoș Alin Rotaru}
\end{flushright}


\vspace{2.5cm}

\centerline{\bf BUCUREȘTI}

\centerline{\bf 2015}

\chapter*{Abstract}

Criptografia modernă se găsește pretutindeni în viața de zi cu zi de la ATM-uri, cartele telefonice la semnături digitale, protocoale de autentificare, licitații electronice sau bani digitali, luând amploare o dată cu apariția sistemelor cu cheie publică. O definiție potrivită este \textit{studiul științific al tehnicilor pentru a securiza informația digitală, tranzacțiile și calculul distribuit}. \cite{Katz:2007}

În cadrul criptografiei există primitive multiple care stau la baza tutoror protocoalelor precum: semnături digitale, funcții one-way (hash), scheme de partajare, schimbul sigur de chei. Un rol important îl deține criptografia de grup, care permite definirea și analiza securității unor protocoale la care iau parte mai mult de 2 participanți.

Păstrarea confidențialității și redundanței datelor pe perioade lungi de timp reprezintă o sarcină dificilă din cauza multiplelor probleme care pot apărea precum atacuri, erori umane, defecțiunea unor componente hardware sau dezastre naturale. \cite{SGMV:2009}
Problemele sunt cu atât mai actuale astăzi, când organizațiile își păstrează datele în cloud pentru scăderea costurilor necesare întreținerii unui centru propriu de date (datacenter), deci informațiile sunt stocate și procesate în afara unui control fizic al proprietarului.


Lucrarea de față analizează câteva dintre primitivele criptografice prezentând apoi protocoale construite pe baza lor. In primele 2 capitole sunt descrise ...

In final introducem o arhitectură implementată cu ajutorul schemelor de partajare eliminând astfel câteva vulnerabilități prezente la sistemele menționate anterior.


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\setcounter{tocdepth}{3}
\tableofcontents



%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------



% 					Structura
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\chapter*{Structură}
\addcontentsline{toc}{chapter}{Structură}

\begin{itemize}
	%\item Secțiunea {\ref{sec:intro}} descrie pe scurt obiectul de studiu.
	\item \todo{Completeaza descrierea}
	\item Secțiunea {\ref{sec:splitting_schemes}} oferă o scurtă introducere în domeniul schemelor de partajare și descrie în detaliu construcțiile care vor fi folosite în secțiunile următoare.
	\item Secțiunea {\ref{sec:long_term_systems_full}} conține cerințele pe care trebuie să le îndeplinească un sistem de stocare de lunga durată și compară sistemele de stocare de lungă durată care utilizează criptarea cu sistemele de stocare bazate pe scheme de partajare a secretelor. De asemenea, sunt descrise câteva sisteme considerate relevante pentru întelegerea contribuțiilor până în prezent.
	\item Secțiunea {\ref{sec:desc_alouneh}} introduce un sistem de stocare criptanalizat.
	\item Secțiunea {\ref{sec:alouneh_contributions}} conține contribuțiile de cercetare, punând în evidență problemele cauzate de determinismul sistemului introdus în Secțiunea {\ref{sec:desc_alouneh}}.
\end{itemize}





%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------




%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\section{Introducere + Motivatie - deocamdata text reciclabil}
\label{sec:intro}

Termenul de criptografie este definit in dicționarul Oxford ca fiind \textit{arta de a scrie și a rezolva coduri}.
Criptografia modernă s-a desprins de cea clasica în jurul anilor '80, motivând implementarea rigurozității matematice pentru definirea construcțiilor criptografice. Aceasta pentru ca în anii anteriori, experiența a dovedit nesiguranța metodelor de criptare, criptanaliza lor fiind uneori trivială (cifrul lui Cezar, Vigenere \cite{Caesar:2015}, \cite{Vigenere:2015}) sau uneori atinsă cu ceva mai mult efort precum Enigma și alte metode din cel de-al doilea război mondial. \cite{Enigma:2015}

Schemele de partajare sunt utilizate în aplicații precum: protejarea și recuperarea cheilor criptografice, vot electronic, certificate distribuite unor autorități, licitații on-line sau sisteme de stocare de lungă durată. \cite{Martin:2008}

O schemă de partajare reprezintă o metodă de a distribui un secret unor participanți, oferind fiecărui participant o componentă (share) astfel încât doar o submulțime de participanți pot recupera secretul inițial.

Cum volumul de datelor electronice este în continuă creștere, necesitatea stocării sigure a devenit extrem de necesară.

Date sensibile trebuie menținute secrete, câteodată pentru lungi perioade de timp (zeci de ani). Exemple includ informații militare, documete legale sau dosare medicale: informațiile militare pot fi clasificate zeci de ani, un testament trebuie menținut secret până la deschiderea sa oficială, un dosar medical necesită păstrare sigură (cel puțin) pe toată durata vieții pacientului.



%----------------------------------------------------------------
%----------------------------------------------------------------
%----------------------------------------------------------------
%----------------------------------------------------------------






%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\chapter{Funcții Pseudoaleatoare}
\label{cha:prf}

\section{Introducere}

\section{Definiții de Securitate}
\label{subsec:prf-security}

\section{Funcții Pseudoaleatoare Constrânse}
\label{subsec:cprf}

%----------------------------------------------------------------
%----------------------------------------------------------------
%----------------------------------------------------------------
%----------------------------------------------------------------









%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\chapter{Schimb de chei non-interactiv}
%this can be revised
\label{cha:nike}

\section{ID-NIKE}
\label{sec:id-nike}

\subsection{Construcția Boneh Waters (2013)}
\label{subsec:boneh-waters}

\section{Multi-party ID NIKE}
\label{subsec:multi-party-id}

\todo{redenumeste multi-party}

\subsection{Proprietăti de securitate}
\label{subsec:multi-party-security}

\subsection{Construcție Multi-Party ID NIKE bazată pe funcții pseudoaleatoare constrânse}
%gee, e mult mai usor in engleza
\label{subsec:multi-party-prf}

\section{Contribuții}
\label{sec:multi-party-contributions}


%----------------------------------------------------------------
%----------------------------------------------------------------
%----------------------------------------------------------------
%----------------------------------------------------------------




%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\chapter{Scheme de Partajare}
\label{chap:secret_sharing}


\section{Introducere}
\label{sec:intro_secret_sharing}

O schemă de partajare constă în distribuirea unei informații secrete $\mathcal{S}$ la mai mulți participanți $\mathcal{P} = \{P_1, \dots, P_n\}$ astfel încât oricare mulțime de participanți, predefinită ca făcând parte dintr-o structură de acces pe care o vom denumi $\mathcal{A}$, să poată reconstitui secretul $\mathcal{S}$.
Formal, o schemă de partajare este reprezentată de o pereche de algoritmi \textbf{$(Gen, Rec)$}:
\begin{itemize}
	\item \textit{$Gen(S, m)$} este un algoritm care primește la intrare un secret \textit{S} și un număr întreg $m$ și întoarce un set de componente ${s_1, s_2, \dots, s_m}$.
	\item \textit{$Rec({s_i}_1, {s_i}_2, \dots, {s_i}_q)$} este un algoritm care primește ca parametri de intrare o mulțime de componente și întoarce \textit{S} dacă mulțimea $\{{P_i}_1, {P_i}_2, \dots, {P_i}_q \} \in \mathcal{A}$.
\end{itemize} 

Majoritatea schemelor constau în mai multe etape precum:
\begin{itemize}
	\item \textit{Inițializare}. Presupune inițializarea variabilelor de mediu necesare.
	\item \textit{Generare}. O entitate autorizată (numită dealer) $\mathcal{D}$ folosește algoritmul \textit{Gen} pentru a genera componentele.
	\item \textit{Distribuție}. Componentele sunt trimise participanților cu ajutorul unui mijloc de comunicare sigur, fără ca acestea sa fie vizibile unui atacator.
	\item \textit{Reconstrucție}. Dându-se o mulțime de componente, se folosește algoritmul \textit{Rec} pentru a recupera secretul
	$\mathcal{S}$.
\end{itemize}

Schemele de partajare se clasifică în funcție de cantitatea de informație secretă pe care o pot obține persoanele care nu fac parte din $\mathcal{A}$:
\begin{itemize}
	\item \textit{Sisteme perfecte de partajare}: componentele nu oferă nici o informație teoretică despre $\mathcal{S}$ indiferent de resursele computaționale.
	\item \textit{Sisteme statistic sigure}: o fracțiune de informație este dezvaluită despre $\mathcal{S}$, independent de puterea computațională a adversarului.
	\item \textit{Sisteme computațional-sigure de partajare}: se bazează pe faptul că reconstituirea lui $\mathcal{S}$ se reduce la o problema \textit{dificilă} (spre exemplu, problema Diffie-Hellman \cite{boneh:1998decision} ) în lipsa unor informații oferite doar grupului de acces $\mathcal{A}$. \cite{Martin:2008}

\end{itemize} 

Primele scheme de partajare au fost dezvoltate independent de Shamir și Blakley în 1979 \cite{B:1979, S:1979}.

Denumite și scheme majoritare $(k, n)$, acestea rezolvau cazul în care oricare grup de participanți cu un număr mai mare sau egal decât $k$  (mărimea pragului) pot reconstitui secretul $\mathcal{S}$ din componentele primite de la dealerul $\mathcal{D}$. Dacă schema este perfect \textit{sigură} atunci oricare grup cu un număr de participanți mai mic decât $k$ nu obține nici o informație despre $\mathcal{S}$.


Schemele majoritare (spre exemplu schema Shamir) sunt insuficiente pentru a permite partajarea pentru anumite structuri de acces. Considerăm cazul în care dorim să partajăm un secret între $4$ participanți: $P_1, P_2, P_3, P_4$ astfel încât $\{P_1,P_2\}$ și $\{P_3,P_4\}$ să fie singurele mulțimi autorizate pentru reconstrucția secretului $S$ (i.e. $\mathcal{A} = \{ \{P_1,P_2\}, \{P_3,P_4\} \}$). În mod evident, problema nu poate fi rezolvată cu o structură de acces de tip prag: anumite mulțimi cu un număr de $2$ participanți trebuie să poată reconstrui secretul ($ \{P_1,P_2\}, \{P_3,P_4\} $), în timp ce altele nu $( \{P_1,P_3\}, \{P_1,P_4\}, \{P_2,P_3\}, \{P_2,P_4\} $)

Astfel de scheme de partajare pentru structuri de acces generale au fost dezvoltate de Ito, Saito și Nishizeki, realizând o generalizare a schemei Shamir. \cite{ITO:1989}
Benaloh și Leichter au demonstrat că schemele de partajare de tip prag nu pot fi folosite pe structuri general monotone (familie de submulțimi ale lui $\mathcal{P}$ cu proprietatea că dacă $A \in \mathcal{A}$ și $A \subset A'$, atunci $A' \in \mathcal{A}$) și obțin o construcție mai eficientă ca Ito et. al din punct de vedere al numărului de componente distribuite participanților. \cite{JJ:1990}

\section{Schema unanimă}

Presupunând că împărțim un secret $\mathcal{S}$ la $n$ participanți astfel încât $\mathcal{S}$ să poată fi recuperat doar dacă toți cei $n$ participanți își combină componentele pe care le dețin. Metoda este echivalentă cu o schemă $(n, n)$ majoritară. Un exemplu este schema introdusă de Karin, Greene și Hellman (Fig.\ref{fig:all_or_nothing}). \cite{Karnin:83}


%---------------- Figure - all_or_nothing - START ------------------------
\begin{figure*}[h!]

\begin{tabular}{|p{\textwidth}|}
\hline

\\
\hspace{.1in}
\textbf{Inițializare}: 
	\begin{itemize}
		\item Fie $S \in Z_q$ unde $q > 1 $ și $q$ prim;
		\item Fie $n$ numărul de participanți;
	\end{itemize}
\medskip

\hspace{.1in}
\textbf{Generare}: Dealerul $\mathcal{D}$:
	\begin{itemize}
		\setlength{\itemsep}{5pt}
		\item Alege $n - 1$ valori aleatoare $s_i \leftarrow^R Z_p$, $i \in \{1,2,\dots,{n-1}\}$;
		\item $s_n = S + \sum\limits_{i=1}^{n-1} s_i \Mod q $;
	\end{itemize}
\medskip

\hspace{.1in}
\textbf{Distribuție}: Dealerul $\mathcal{D}$:
	\begin{itemize}
		\item transmite în mod sigur participantului $P_i$ componenta $s_i$, $i \in \{1,2,\dots,n\}$;
	\end{itemize}

\hspace{.1in}
\textbf{Reconstrucție}: Cei $n$ participanți:
	\begin{itemize}
		\item Calculează $S = \sum\limits_{i=1}^{n} s_i \Mod q$.
	\end{itemize}

\\
\hline
\end{tabular}
\caption{Schema unanimă \cite{Karnin:83}}
\label{fig:all_or_nothing}
\end{figure*}

%---------------- Figure - all_or_nothing- STOP ------------------------



\section{Schema Shamir}

Schema Shamir oferă mai multă flexibilitate decât schema unanima prin faptul ca oricare $k$ (sau mai mulți) participanți
din cei $n$ pot recupera $\mathcal{S}$, însă mai puțin de $k$ participanți nu obțin nicio informație despre $\mathcal{S}$. Schema Shamir este deci o schemă $(k,n)$ majoritară.

Intuitiv, având $k$ puncte in plan $(x_i, y_i)$, $x_i \neq x_j \text{ } i,j \in \{1,2,\dots,k\}$ $\forall i \neq j$, există o curbă polinomială unică de grad $k - 1$ ce trece prin ele.  
În schimb, pentru a defini o curbă polinomială de grad $k$ care trece prin $k - 1$ puncte date, există o infinitate de soluții.
Evident, orice submulțime de valori $s_i$ de mărime egală cu $k$ este suficientă și necesară pentru a reconstrui polinomul $f$. După interpolarea componentelor deținute de cel puțin $k$ dintre participanți, secretul $\mathcal{S}$ se află în $f(0)$ (Fig. \ref{fig:shamir_scheme}). \cite{S:1979}

Pentru un atacator care deține chiar și $k-1$ valori $s_i$, acesta nu determină nimic despre $\mathcal{S}$, spațiul de soluții posibile fiind identic față de situația în care deține $0$ componente.

%---------------- Figure - shamir_scheme - START ------------------------
\begin{figure*}[h!]

\begin{tabular}{|p{\textwidth}|}
\hline

\\
\hspace{.1in}
\textbf{Inițializare}: 
	\begin{itemize}
		\item Fie $S \in Z_q$ unde $q > 1 $ și $q$ prim;
		\item Fie $n$ numărul de participanți a.î. $q > n$;
		\item Fie $k$ numărul minim de componente puse în comun pentru a determina $\mathcal{S}$;
	\end{itemize}
\medskip

\hspace{.1in}
\textbf{Generare}: Dealerul $\mathcal{D}$:
	\begin{itemize}
		\item Alege $n$ valori distincte $x_i \leftarrow^R Z_q \setminus \{0\} \text{, }i = 1,2,\dots, n$;
		\item Alege $a_{i} \leftarrow^R Z_q \text{, }i \in \{1,2,\dots,{k - 1}$\}, $a_{k-1} \neq 0$;
		\item Construiește polinomul $f(x) = a_{k - 1}x ^ {k-1} + a_{k-2}x ^ {k - 2} + \dots + a_1x + \mathcal{S}$;
		\item Calculează $s_i = f(x_i) \text{ }, i \in \{1,2,\dots,n\}$;
	\end{itemize}
\medskip

\hspace{.1in}
\textbf{Distribuție}: Dealerul $\mathcal{D}$:
	\begin{itemize}
		\item Transmite participantului $P_i$ componenta $s_i$, $i \in \{1,\dots,n\}$;
	\end{itemize}

\hspace{.1in}
\textbf{Reconstrucție}: Orice mulțime cu dimensiunea $k$ (sau mai mare) de participanți distincți $P_1, P_2, \dots, P_k$:
	\begin{itemize}
		\setlength{\itemsep}{5pt}
		\item Interpolează punctele $s_i$ pentru a obține polinomul $f$:
		\begin{equation} f(x)=\sum_{i=1}^{k} {s_i}\prod_{1 \leq j \leq k, j \neq i} \frac{x-x_j}{x_i-x_j} \end{equation}
		\item Află secretul reconstruit $S = f(0)$.
	\end{itemize}

\\
\hline
\end{tabular}

\caption{Schema Shamir \cite{S:1979}}
\label{fig:shamir_scheme}
\end{figure*}

%---------------- Figure - shamir_scheme- STOP ------------------------

\section{Schema Ito, Saito și Nishizeki}
\label{Ito}

În continuare vom descrie modalitatea de distribuire a componentelor de la care au pornit Ito, Saito și Nishizeki pentru ca schema sa aibă o structură de acces $\mathcal{A} \subseteq 2^P$ (submulțime a setului de participanți) monotonă (i.e. $\forall A \in \mathcal{A}, A \subseteq A' \Rightarrow A' \in \mathcal{A}$) \cite{ITO:1989}. 
Folosind construcția unei scheme majoritare $(k, n)$ autorii au reușit să descrie elementele din $\mathcal{A}$ folosind rezultatul unei reuniuni de mulțimi de componente cu un număr de elemente mai mare sau egal decât $k$ (Fig. \ref{fig:ito_et_al}). \cite{ITO:1989} Notația $x : Pr$, înseamnă că $x$ are proprietatea $Pr$. 

Dezvantajul acestei structuri este numărul de componente necesar pentru o structură de acces oarecare $\mathcal{A}$. Un mod simplu de construire al funcției $Assign$ din figura Fig. \ref{fig:ito_et_al} este următorul: pentru fiecare mulțime minimală $A \in \mathcal{A}$ ($\forall B \in \mathcal{A}$, $B \neq A, B \not\subset A$) se folosește o schemă de partajare unanimă $(|A|, |A|)$ a lui $\mathcal{S}$ pentru participanții din $A$.

\begin{exemplu}
	Fie structura de acces $\mathcal{A} = \{ \{P_1, P_2\},\{P_1, P_3, P_4\}\}$.
	\begin{itemize}
		\item Generăm componentele $s_1, s_2$ a.î. $s_1 \oplus s_2 = \mathcal{S}$ cu ajutorul schemei unanime $(2,2)$, 
		\item Generăm componentele $s_3, s_4, s_5$ a.î. $s_3 \oplus s_4 \oplus s_5 = \mathcal{S}$ cu ajutorul schemei unanime $(3,3)$
	\end{itemize}
	Participanții primesc in felul următor componentele:
	\begin{itemize}
		\item $P_1: \{s_1, s_3\}$;
		\item $P_2: \{s_2\}$;
		\item $P_3: \{s_4\}$;
		\item $P_4: \{s_5\}$;
	\end{itemize}
\end{exemplu}

%---------------- Figure - Ito_et_al- START ------------------------
\begin{figure*}[h!]

\begin{tabular}{|p{\textwidth}|}
\hline

\\
\hspace{.1in}
\textbf{Inițializare}: 
	\begin{itemize}
		\item Fie $q$ un număr prim $q$, $q > 1$, $z \in \mathbb{N}$ nenul și $\mathcal{C} = GF(p^z)$;
		\item Fie $S \in \mathcal{C}$ secretul; 
		\item Fie structura de acces $\mathcal{A}$;
		\item Fie $n$ numărul de participanți;
	\end{itemize}

\medskip

\hspace{.1in}
\textbf{Generare}: Dealerul $\mathcal{D}$:
	\begin{itemize}
		\setlength{\itemsep}{5pt}
		\item Alege $n$ valori distincte $x_i \leftarrow^R Z_q \text{, }i = 1,2,\dots,n$;
		\item Alege $a_{i} \leftarrow^R \mathcal{C} \setminus \{0\} \text{, }i \in \{1,2,\dots,{k - 1}\}$, $a_{k-1} \neq 0$;
		\item Construiește polinomul $f(x) = a_{k - 1}x ^ {k-1} + a_{k-2}x ^ {k - 2} + .... + a_1x + \mathcal{S}$;
		\item Atribuie $s_i = f(x_i) \text{ } i \in \{1,2,\dots,n\}$; Fie $Shares = \{ s_1, \dots, s_n \}$;
		\item Alege $D_i \subseteq Shares \text{ } 1 \leq i \leq n$;
		\item Alege funcția $Assign: P \rightarrow 2^Q$:
			\begin{itemize}
				\item $Assign(P_i) = D_i \text{ } 1 \leq i \leq n$
				\item $\mathcal{A} = \bigg \{ \ Q \subseteq Shares: \bigg| \underset{P_i \in Q}{{\bigcup}} Assign(P_i) \bigg| \geq k \bigg \}$;
				% : <=> having property
			\end{itemize}
	\end{itemize}
\medskip

\hspace{.1in}
\textbf{Distribuție}: Dealerul $\mathcal{D}$:
	\begin{itemize}
		\item Transmite participantului $P_i$ componenta $Assign(P_i)$, $i \in 1,2,\dots,n$;
	\end{itemize}

\hspace{.1in}
\textbf{Reconstrucție}: Participanții din structura de acces $\mathcal{A}$:
	\begin{itemize}
		\item Procedează identic ca în schema Shamir.
	\end{itemize}


\\
\hline
\end{tabular}

\caption{Schema Ito, Saito, si Nishizeki \cite{ITO:1989}}
\label{fig:ito_et_al}
\end{figure*}

%---------------- Figure - Ito_et_al - STOP ------------------------

%----------------------------------------------------------------
%----------------------------------------------------------------
%----------------------------------------------------------------
%----------------------------------------------------------------
%----------------------------------------------------------------

\section{Schema Feldman}
\label{sec:feldman_scheme}

Uneori, canalul de comunicaţie prin intermediul căruia dealerul $\mathcal{D}$ transmite componentele nu este întotdeauna sigur. Din fericire, participanții pot constata cu ușurință integritatea componentelor primite folosind scheme de verificare. Primele direcții către astfel de construcții au fost oferite în anul $1985$ de către Chor et al. \cite{chor:1985verifiable}

În continuare vom exemplifica o schemă de verificare non-interactivă precum cea a lui Feldman, construită pe baza schemei Shamir. (Fig. \ref{fig:feldman_scheme}). \cite{Feldman:1987} Spre deosebire de schema Shamir, securitatea schemei Feldman este una computațională și deține un model de adversar pentru care problema logaritmului discret este dificilă.

%---------------- Figure - feldman_scheme - START ------------------------
\begin{figure*}[h!]

\begin{tabular}{|p{\textwidth}|}
\hline

\\
\hspace{.1in}
\textbf{Inițializare}: 
	Folosind notațiile din Fig. \ref{fig:shamir_scheme}, considerăm polinomul $f$ generat în urma Schemei Shamir.
	\begin{itemize}
		\item Se alege un $g \in Z_q$ generator al lui $Z_q$ a.î. este dificil de calculat $\log_g x$
	\end{itemize}
\medskip

\hspace{.1in}
\textbf{Generare}: Dealerul $\mathcal{D}$:
	\begin{itemize}
		\item Calculează \textit{angajamentele}: $c_0 = g^S$, $c_j = g^{a_j}$, $j \in \{1,\dots,k\}$;
	\end{itemize}
\medskip

\hspace{.1in}
\textbf{Distribuție}: Dealerul $\mathcal{D}$:
	\begin{itemize}
		\item Distribuie \textit{angajamentele} $c_j$, $j \in \{0,\dots,k\}$ fiecărui participant $i\in \{1,\dots,n\}$;
	\end{itemize}

\hspace{.1in}
\\
\hline
\end{tabular}

\caption{Schema Feldman \cite{Feldman:1987}}
\label{fig:feldman_scheme}
\end{figure*}
%---------------- Figure - feldman_scheme- STOP ------------------------

Pentru verificarea componentei $s_i = f(i)$, participantul $i$ probează ecuația:

\begin{equation}
	g^{s_i} = c_0c_1^ic_2^{i^2} \dots c_t^{i^t} = \prod_{j=0}^k c_j^{i^j} = \prod_{j=0}^k g^{a_ji^j} = g^{\sum\limits_{j=0}^k a_ji^j} = g^{f(i)}
\end{equation}


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------



\chapter{Sisteme de stocare de lungă durată}


\section{Introducere}
\label{sec:long_term_systems_intro}

Un sistem de stocare, în general, trebuie să satisfacă cel puțin următoarele 3 condiții:
\begin{itemize}
	\item Disponibilitatea: Informația trebuie să rămână accesibilă tot timpul, chiar și în prezența erorilor de tip hardware.
	\item Integritatea: Abilitatea sistemului de a răspunde cererilor într-un mod care garantează corectitudinea lor.
	\item Confidențialitatea: O persoană care nu face parte din grupul de acces să nu obțină permisiunea de a afla informații de orice fel despre datele existente in sistem.
\end{itemize}


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\section{Criptare vs. scheme de partajare}

Una dintre soluțiile existente pentru a construi acest sistem este criptarea datelor folosind o cheie înainte de inserarea lor in spațiul de stocare. în momentul în care un utilizator autorizat dorește să efectueze o citire a unor date, întrebuințează cheia potrivită pentru a le decripta.

în practică există algoritmi de criptare eficienti precum AES însă aceaștia nu garantează confidențialitatea datelor în cazul în care apare un adversar fără o limita computațională.

Un dezavantaj al criptării este adminstrarea cheilor, standardele de securitate schimbându-se în fiecare an.
De fiecare dată când cheile sunt înnoite atunci este necesară recriptarea datelor de pe fiecare bază de date. Cu cât disponibilitatea este mai mare - volumul de date crește - recriptarea informației devine o operație foarte costisitoare. 

Majoritatea tehnicilor de criptarea se bazează pe dificultatea factorizării unui număr sau cea a calculării logaritmului discret însă o dată cu posibila dezvoltare a calculatoarelor cuantice aceste probleme nu vor mai fi atât de dificile \cite{Shor:1994}.
Pentru schemele de partajare, spre desoebire de criptare, avantajul unui adversar nu depinde de puterea sa computațională, acestea garantând securitatea teoretică precum schema Shamir \cite{S:1979}.

Dezavantajul schemelor generale de partajare este dimensiunea componentelor, exponențială în funcție de numărul de participanți. \cite{Survey:2011}

%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------



%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\section{Sisteme de stocare de lungă durată bazate pe scheme de partajare}
\label{sec:long_term_systems_full}

O alternativă la soluția cu criptare care asigură atât confidențialitate cât și redundanța necesară este intrebuințarea sistemelor de stocare de lungă durată bazate pe scheme de partajare \cite{W:2000,SBM:2005,SGMV:2009}.


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
\subsection{PASIS}
\label{sec:desc_pasis}
PASIS este o soluție pentru un sistem descentralizat care oferă beneficii precum securitate, redundanță a datelor si auto-întreținere \cite{W:2000}
Structurile descentralizate împart informația la mai multe noduri folosind scheme de redundanța precum "Redundant Array of Independent Disks" (RAID) pentru a asigura performanța, scalabilitatea sistemului dar și integritatea datelor \cite{Patterson:1988}.
RAID reprezintă o tehnologie ce combină 2 concepte ortogonale precum data striping (aranjarea datelor pe discuri multiple într-o manieră secvențială - Fig \ref{fig:raid_strip}) și redundanță pentru o disponibilitate ridicată \cite{Chen:1994}.

\begin{figure}
	\begin{center}
	\includegraphics[width=0.6\textwidth]{img/raid0.png}
	\caption{Procesul de striping aplicat unui bloc de date}
	\label{fig:raid_strip}
	\end{center}
	\bigskip
\end{figure}

PASIS folosește schemele de partajare pentru a distribui informația nodurilor de stocare dintr-o rețea. Aceasta introduce agenți pe partea clientului pentru a scrie sau șterge date din noduri, dar și agenți pentru mentenanță. Componentele obținute în urma partajării unui fisier sunt stocate in rețea cu ajutorul agenților (Fig. \ref{fig:pasis}). Pe lângă conținutul brut al componentelor se adaugă metadate pentru a reține adresa nodului din rețea la care au fost stocate dar și noua denumire cu care este salvată in rețea.

Atunci când un participant inițiază o cerere pentru a citi un fisier, agentul PASIS aflat local procedează dupa cum urmează:
\begin{itemize}
	\item Caută numele celor $n$ componente care alcătuiesc fișierul într-un serviciu care listează toate datele.
	\item Inițiaza cereri de citire la cel puțin $k$ din cele $n$ noduri.
	\item în caz ca acesta nu primește cel puțin $k$ răspunsuri se întoarce la pasul anterior încercând interogări la noduri diferite.
	\item Reconstituie fișierul obținut din cele $k$ componente.
\end{itemize}
Operația de scriere este similară cu cea de citire, aceasta oprindu-se atunci când în cel puțin $n - k + 1$ noduri s-au stocat cu succes componente.

Autorii specifică soluții pentru auto mentenanța sistemului cu ajutorul resurselor umane prin monitorizarea periodică stării sistemului folosind log-uri sau ajustarea parametrilor din cadrul schemei de partajare.

\begin{figure}
	\includegraphics[width=11cm]{img/PASIS.png}
	\caption{Arhitectura PASIS cu $4$ noduri și $2$ clienți \cite{W:2000}.}
	\label{fig:pasis}
	\bigskip
\end{figure}


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\subsection{GridSharing} 
\label{sec:desc_gridsharing}

în 2005, Subbiah și Blough propun o nouă abordare pentru a construi un sistem de stocare securizat și tolerant la erori numit GridSharing \cite{SB:2005}.

Schema Shamir nu oferă siguranță în ceea ce privește detectarea sau actualizarea unor componente incorecte introduse de un atacator.
Din acest motiv, scheme de verificare precum cele prezentate in Secțiunea {\ref{sec:feldman_scheme}} sunt folosite.


Subbiah și Blough folosesc un sistem care înlocuiește schemele de verificare cu o schemă de partajare unanimă XOR (considerăm cazul $q = 2$ în Fig. \ref{fig:all_or_nothing}) pentru a păstra securitatea construcției.
în cazul detectării componentelor incorecte, este adoptată o strategie de tipul replicate-and-voting.
Componentele sunt replicate pe un număr mare de servere astfel încât determinarea validității va fi stabilită în funcție de numărul de servere care le conțin.

Se identifică 3 tipuri de defecțiuni care pot apărea pe serverele unde sunt stocate datele:
\begin{itemize}
	\item Abandonări: un server este \textit{abandonat} dacă nu mai raspunde vreunui mesaj din rețea și s-a oprit din a mai efectua vreo operație.
	\item Bizantine: atunci când serverul nu respectă întotdeauna protocoalele inițiale iar componentele salvate local au fost compromise.
	\item Scurgeri de informații: serverul execută protocoalele corect dar e posibil ca un adversar să fi obținut componentele stocate.
\end{itemize}
Primele 2 modele definite mai sus sunt preluate din calculul cu sisteme distribuite. Cel de-al 3-lea model a fost introdus pentru a defini atacatorul care folosește vulnerabilitățile cu intenția de a \textit{învața} din informații.

Arhitectura GridSharing constă in $N$ servere unde cel mult $c$ servere pot fi abandonate, $b$ servere bizantine și $l$ cu scurgeri de informații. Cele $N$ pot fi aranjate într-un grid cu $r$ linii și $N/r$ coloane (considerăm pentru simplitate că $N \Mod r = 0$). Caracteristicile modelului bizantin și cel specific scurgerilor de informații permit dezvăluirea componentelor unui adversar de pe cel mult $l + b$ servere.

\begin{exemplu}

	Notăm ${x \choose y}$ fiind combinări de $x$ elemente grupate câte $y$.
	Considerăm ca împarțim un secret $\mathcal{S}$ la $4$ linii (participanți) astfel încât sistemul să permită $2$ componente de tip $b$, $1$ componentă de tip $l$ și $20$ servere. în cazul acesta vom folosi o schemă majoritară XOR $\big( {4 \choose 3}, {4 \choose 3}\big) = (4,4)$.

	Vom avea $4$ componente, $(s_1, s_2, s_3, s_4)$ a.î. $s_1 \oplus s_2 \oplus s_3 \oplus s_4 = \mathcal{S}$.
	Distribuirea se face in felul următor:
	\begin{itemize}
		% avem asa: p1, p2, p3, p4; s1, s2, s3
		% (p1 p2 p3, p1 p2 p4, p1 p3 p4, p2 p3 p4)
		% p1 | s4
		% p2 | s3
		% p3 | s2
		% p4 | s1
		\item Serverele situate pe prima linie primesc $s_1$
		\item Serverele situate pe a $2$-a linie primesc $s_2$
		\item Serverele situate pe a $3$-a linie primesc $s_3$
		\item Serverele situate pe a $4$-a linie primesc $s_4$
	\end{itemize}
\end{exemplu}

\begin{figure}[H]
	\includegraphics[width=12cm]{img/GridSharing.png}    % The printed column width is 8.4 cm.
	\caption{GridSharing cu $4$ linii, $20$ servere dintre care $2$ bizantine, $1$ cu scurgeri de informații \cite{SB:2005}.}
	\label{fig:grid_sharing}
	\bigskip
\end{figure}


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\subsection{POTSHARDS} 
\label{sec:desc_potshards}
în $2007$ este propus un nou sistem care combină caracteristicile PASIS și GridSharing adăugând posiblitatea de migrare a datelor la noduri noi: POTSHARDS (Protection Over Time, Securely Harboring And Reliably Distributing Stuff) \cite{SGMV:2009}.

POTSHARDS poate fi gândit ca o aplicație pe partea clientului care comunică cu o mulțime de noduri (arhive) independente, folosind reconstrucția componentelor într-un mod securizat și semnături algebrice pentru a asigura un grad ridicat de păstrare a integritații fișierelor \cite{STM:2006}.

Confidențialitatea este asigurată prin adoptarea unei scheme de partajare XOR unanimă, la fel ca în GridSharing.

Ca prim pas, POTSHARDS preprocesează fișierul într-un obiect, partajează obiectul în fragmente la care adaugă meta-date, numite \textit{shards} (Fig. \ref{fig:data-potshard}). \cite{SGMV:2009} Acestea sunt trimise apoi arhivelor independente, fiecare având propriul domeniu de securitate, localizate in \textit{regiuni}. Pentru a reconstitui cu succes informația inițială, meta-datele shard-urilor conțin detalii despre structura pointerilor aproximativi, indicând regiunea în care se află următorul shard. Pointerii aproximativi sunt folositi pentru a reconstitui intreaga arhiva doar din shard-uri.

\begin{figure}[b!]
	\begin{center}
	\includegraphics[width=7cm, height=4cm]{img/Shards.png}    % The printed column width is 8.4 cm.
	\caption{Entități de date in POTSHARDS. $Nr$ e numărul de shard-uri produse de un fragment.
		$SplitXOR$ reprezintă o componentă rezultată în urma partajarii unanime XOR. Analog $SplitShamir$ reprezintă o componentă rezultată în urma partăjarii folosind schema Shamir \cite{SGMV:2009}}
	\label{fig:data-potshard}
	\bigskip
	\end{center}
\end{figure}

Procesul de fragmentare a datelor este prezentat in Fig. \ref{fig:potshards-layers}.


\begin{figure}
	\begin{center}
	\includegraphics[width=12cm]{img/POTSHARDS.png}    % The printed column width is 8.4 cm.
	\caption{Distribuirea unui obiect in POTSHARDS}
	\label{fig:potshards-layers}
	\bigskip
	\end{center}
\end{figure}

Pentru ca reconstituirea unui fișier sa fie fezabilă unui utilizator, acestuia îi este întoarsă o listă cu locațiile exacte shard-urilor corespunzătoare.
Obținerea unui shard de către un atacator nu este folositoare, pentru a detecta următorul shard, un atac brut force constă în cereri multiple în zona indicată de pointerul aproximativ. Un astfel de atac nu va trece neobservat de POTSHARDS deorece unul dintre scopurile sale este să stocheze datele într-un mod cat mai uniform distribuit\cite{SGMV:2009}.


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\section{Sistemul de stocare Alouneh et al. (2013)}
\label{sec:desc_alouneh}

Alouneh et al. propun un sistem pentru stocarea sigură a datelor un timp indelungat folosind schema Shamir cu câteva modificări. Aceste schimbări se vor arăta esențiale mai târziu în menținerea securității \cite{AAMK:2013}.

Pentru stocarea unui fișier în sistem (abordând filozofia majorității sistemelor de operare - orice este un fișier), o aplicație client îl împarte în blocuri de octeți de lungime $k$. Pentru fiecare bloc, octeții devin coeficienții unui polinom $f$ de grad $k$, componenta corespunzătoare participantului $i$ va fi reprezentată de valoarea lui $f(i)$, $i = \{1,2,\dots, n\}$. 
Menționăm că toate operațiile se vor efectua in $GF(256)$ modulo un polinom ireductibil (în implementarea sistemului, autorii folosesc $x^8 + x^5 + x^3 + x + 1$). Procedeul este descris in detaliu in Fig \ref{fig:alouneh_distribution}.


%---------------- Figure - alouneh-distribution - START ------------------------
\begin{figure*}[h!]

\begin{tabular}{|p{\textwidth}|}
\hline

\\
\hspace{.1in}
\textbf{Date de intrare}: Un fișier binar $\mathcal{S}$;
\medskip

\hspace{.1in}
\textbf{Date de ieșire}: $n$ fișiere binare distribuite la noduri din rețea;
\medskip

\hspace{.1in}
\textbf{Procesarea componentelor}: Aplicația existentă pe partea clientului: 
	\begin{itemize}
		\item Dacă $\mathcal{S}$ nu are o lungime divizibilă cu $k$:
			\begin{itemize}
			\item Concatenează la sfârsitul lui $\mathcal{S}$ octeți până când $len(\mathcal{S}) \Mod k = 0$;
			\end{itemize}
		\item împarte $\mathcal{S}$ în blocuri de lungime $k$;
		\item Repetă pentru fiecare bloc $B_t$ de lungime $k$:
		\begin{itemize}
			\item Construiește polinomul $f(x) = B_{t_{k - 1}}x ^ {k-1} + B_{t_{k - 2}}x ^ {k - 2} + .... + B_{t_1}x + B_{t_0}$;
			\item Calculează $f(i)$ pentru $1 \leq i \leq n$;
		\end{itemize}
	\end{itemize}

\hspace{.1in}
\textbf{Distribuție}: Aplicația la nivelul clientului:
	\begin{itemize}
		\item Distribuie componenta $f(i)$ nodului din rețea cu indicele $i$:
	\end{itemize}

\\
\hline
\end{tabular}
\caption{Schema Alouneh et al. - Generare \cite{AAMK:2013}}
\label{fig:alouneh_distribution}
\end{figure*}

%---------------- Figure - alouneh_distribution - STOP ------------------------

\begin{exemplu}
Vom exemplifica modul de calcul în $GF(256) \Mod {g(x)} $ unde $g(x) = x ^ 8 + x ^ 4 + x ^ 3 + 1$. Luăm polinomul $f(x) = 10 + 15x$ corespunzâtor unui fișier format din octeții (în această ordine) $10$ $15$.
	\begin{equation} \label{eq:f_01}
	\begin{split}
		f(01) \Mod{g(x)} & = 10 + 15 \Mod{g(x)} \\
		& = (x ^ 4) + (x ^ 4 + x ^ 2 + 1) \Mod{g(x)} \\
		& = x ^ 2 + 1 = 000000101_{(2)} \\
		& =  05_{(16)}
	\end{split}
	\end{equation}

	\begin{equation} \label{eq:f_02}
	\begin{split}
	 f(02) \Mod{g(x)} & = 10 + 15\cdot02 \Mod{g(x)} \\
	 & = (x ^ 4) + (x ^ 5 + x ^ 3 + x) \Mod{g(x)} \\
	 & = 00111010_{(2)} \\
	 & = 3A_{(16)}
	 \end{split}
	 \end{equation}
\end{exemplu}
Reconstituirea unui fișier (Fig. \ref{fig:alouneh_reconstruction}) se realizează din orice mulțime de componente $A$ de dimensiune minim $k$ folosind interpolarea Lagrange (utilizată și în cadrul schemei Shamir):
\begin{equation}
	\label{eq:lagrange_poly}
	f(x)=\sum_{i \in A} f(i) \prod_{j \in A, j \neq i} \frac{x-j}{i-j}
\end{equation}

\begin{exemplu}
Vom exemplifica interpolarea conform ecuației {\ref{eq:lagrange_poly}} folosind componentele (\ref{eq:f_01}) și (\ref{eq:f_02}) calculate în exemplul anterior:
	\begin{equation}
	\begin{split}
		f(x) & = 05(x - 02)(01 - 02)^{-1} + 3A(x - 01)(02 - 01)^{-1} \\
		& = 05(x - 02)03^{-1} + 3A(x - 01)03^{-1} \\
		& = F6(05 + 3A)x + F6(05\cdot02 + 3A \cdot 01) \\
		& = F6\cdot 3F\cdot x + F6\cdot30 = 15x + 10
	\end{split}
	\end{equation}
\end{exemplu}

Noutatea arhitecturii constă in diminuarea redundanței componentelor la un factor de $k$, spre deosebire de sistemele descrise in Secțiunile \ref{sec:desc_pasis}, \ref{sec:desc_gridsharing} și \ref{sec:desc_potshards}. Reducerea spațiului ocupat de componente este datorat înlocuirii coeficienților generați aleator din schema Shamir cu octeții din fișierul ce va fi partajat, fiecare componentă având nevoie de $1/k$ din dimensiunea fișierului $\mathcal{S}$.

Abordarea acestei metode deterministe conduce la insecuritatea sistemului, Alouneh et al. afirmând în mod eronat că securitatea este indusă în mod automat de schema Shamir. 

%---------------- Figure - alouneh-reconstruction- START ------------------------
\begin{figure*}[h!]

\begin{tabular}{|p{\textwidth}|}
\hline

\\
\hspace{.1in}
\textbf{Date de intrare}: Cel puțin $k$ componente provenite din noduri (distincte);
\medskip

\hspace{.1in}
\textbf{Date de ieșire}: Fișierul binar original $\mathcal{S}$;
\medskip

\hspace{.1in}
\textbf{Reconstrucție}: Aplicația existenta pe partea clientului: 
	\begin{itemize}
		\item Repetă pentru fiecare bloc al lui $\mathcal{S}$:
		\begin{itemize}
			\item Calculează prin interpolare coeficienții lui $f(x)=B_{t_{k - 1}}x ^ {k-1} + B_{t_{k - 2}}x ^ {k - 2} + .... + B_{t_1} + B_{t_0}$
			\item Reconstituie blocul $B_t$
		\end{itemize}
		\item șterge octeții de la sfârșitul fișierului adăugați la generare. 
	\end{itemize}

\\
\hline
\end{tabular}
\caption{Schema Alouneh et al. - Reconstrucție \cite{AAMK:2013}}
\label{fig:alouneh_reconstruction}
\end{figure*}

%---------------- Figure - alouneh_reconstruction- STOP ------------------------



%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\section{Contribuții}
\label{sec:alouneh_contributions}

\todo{Reformulare}
împreună cu mentorul am analizat sistemul Alouneh et al. prezentat în Secțiunea \ref{sec:desc_alouneh}. \cite{AAMK:2013}
 Am indentificat erori majore ale acestuia și am implementat sistemul descris de autori pentru a demonstra practic, nu doar teoretic anumite greșeli pe care le vom evidenția în următoarele secțiuni.

\subsection{Vulnerabilități evidențiate}

Spre deosebire de schema Shamir, unde coeficienții (cu excepția termenului liber, care este egal cu secretul) sunt aleși într-un mod aleator uniform, sistemul propus de Alouneh et al. folosește o schemă modificată Shamir în care coeficienții sunt extrași din conținutul fișierelor originale.
Alegerea este motivată de faptul ca mulțimea componentelor și efortul computațional depus pentru generarea coeficienților se reduce la un factor de $k$ ori, spre deosebire de schema Shamir.

Datorită determinismului, partajarea unui fișier de mai multe ori implică obținerea de componente identice.
Determinismul duce la câteva atacuri simple în momentul în care un atacator obține informațiile stocate într-un nod, indiferent de mărimea pragului folosit în metoda de partajare. în acest sens, am evidențiat $2$ atacuri simple în cazul în care componentele sunt calculate in ordine ($f(01), f(02), \dots$):
\begin{itemize}
	\item Detectarea tipului unui fișier
	\item Detectarea conținutului unui fișier
\end{itemize}

Deoarece Alouneh et al. nu menționeaă o metoda de padding, am indicat că un atac bazat pe felul în care se realizează completarea fișierului (padding) $\mathcal{S}$ înainte de partajarea sa poate fi fezabil, în condițiile în care s-a demonstrat ca această alegere este esențială în păstrarea securității \cite{Vaudenay:2002}.

\subsubsection{Detectarea tipului de fișier}\hspace*{\fill} \\
\label{subsec:file_type_detection}

în tehnologia informației, la inceputul fiecărui fișier se află o secvență de octeți (denumită semnatură sau antet) cu rolul de a identifica tipul acestuia. Tabelul {\ref{table:sign}} indică $7$ din cele mai uzuale antete.


%-----------------------------------------------------
\begin{table}[b]
\bigskip
\begin{center}
\caption{Semnături de fișiere}\label{tb:margins}
\label{table:sign}
\begin{tabular}{ccccc}
Tip de fișier &  \multicolumn{4}{c}{Primii 4 octeți}\\ \hline 
doc &  D0 & CF & 11 & E0\\
gif & 47 & 49 & 46 & 38 \\
pdf & 25 & 50 & 44 & 46 \\
png & 89 & 50 & 4E & 47 \\
rar & 52 & 61 & 72 & 21 \\
wav & 52 & 49 & 46 & 46 \\
zip & 50 & 4B & 03 & 04\\  \hline
\end{tabular}
\end{center}
\bigskip
\end{table}

Se consideră cazul în care partajarea unui fișier \textit{pdf} se face cu ajutorul sistemului descris in {S}ecțiunea \ref{sec:desc_alouneh}, folosind $k \leq 4$. Polinomul corespunzător $f(x)$ va fi intotdeauna același. Presupunând ca numerotarea nodului $i$ este aceeași, putem determina cu ușurință dacă este stocat un fișier \textit{pdf} fără a lua în calcul conținutul fișierului.
Acest atac este fezabil deorece valoarea lui $k$ este publică iar $i$ poate sa fie descoperit în momentul distribuirii.

Cu alte cuvinte, dacă un adversar obt\c{i}ne controlul unui singur nod, bazându-se doar pe valoarea primei componente poate detecta tipul unui fișier.

Pentru a exemplifica, un adversar poate distinge cu probabilitate ridicată între fișierele \textit{doc, gif, pdf, png, rar, wav} și \textit{zip}. în Tabelul {\ref{table:shares}} avem generate componentele pentru $k = 2$ și $n = 5$.
Dacă un adversar descoperă valoarea primului nod iar prima componentă este $14$ atunci acesta știe cu certitunde că aceasta corespunde un fișier \textit{gif}. Dacă obține accesul nodului $4$ și citește valoarea $205$ atunci știe că fișierul este de tipul \textit{rar}. Daca citește valoarea $27$ de pe primul nod atunci știe că poate fi un \textit{wav} sau \textit{zip}; dar poate să distingă cele 2 fișiere cu probabilitate $1$ dacă dezvăluie o singură valoare de pe celelalte noduri ($2$, $3$, $4$ sau $5$) pentru că valorile sunt distincte.


%-----------------------------------------------------
\begin{table}[t]
\begin{center}
\caption{Componentele primului bloc ($k=2$)}\label{tb:margins}
\label{table:shares}
\begin{tabular}{cccccccc}
Tip fisier & Nod 1 & Nod 2 & Nod 3 & Nod 4 & Nod 5 \\
  & ($i=1$) & ($i=2$) & ($i=3$) & ($i=4$) & ($i=5$) \\
\hline
doc & 31 & 85 & 154 & 193 & 14 \\
gif & 14 & 213 & 156 & 120 & 49 \\
pdf & 117 & 133 & 213 & 126 & 46 \\
png & 217 & 41 & 121 & 210 & 130 \\ 
rar & 51 & 144 & 241 & 205 & 172  \\
wav & 27 & 192 & 137 & 109 & 36 \\
zip & 27 & 198 & 141 & 103 & 44 \\ \hline
\end{tabular}
\end{center}
\bigskip
\end{table}


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------


\subsubsection{Detectarea de conținut}\hspace*{\fill} \\
\label{subsec:file_content_detection}

Multe documente urmează un anumit tipar precum contracte, chitanțe, bonuri fiscale sau curriculum vitae. Deoarece majoritatea conținutului rămâne neschimbat, există o probabilitate destul de mare ca multe componente sa aiba aceeași valoare. O dată ce un adversar reușește să determine componentele unui nod, poate determina prin analogie tipul de conținut al fișierului original.

Fișierele vulnerabile sunt cele care conțin o secvență de octeți periodică (imagini cu un pattern repetitiv) sau cele care au preponderent octeți nuli (valoarea componentelor asociată majorității blocurilor fiind $0$). Spre deosebire de prima metodă, aceasta nu necesită compararea cu un al $2$-lea fișier, tratând componentele de sine stătător. Multiple componente identice indică existența unor secvențe repetitive în conținutul fișierului.


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\subsection{Implementare și rezultate practice}
Pentru a arăta aplicabilitatea rezultatelor în practică, am implementat propunerea descrisa in Secțiunea {\ref{sec:desc_alouneh}} și am testat pe câteva cazuri.

în cadrul implementării am folosit limbajul Python 3.0 sub sistemul de operare ArchLinux. Python este un limbaj high-level, permițând programatorilor să exprime concepte în mai puține linii de cod față de C++ sau Java și este disponibil sub licență open-source \cite{Python:2015}.
Pentru a realiza comunicarea între procese am folosit Cerealizer iar distribuția componentelor a fost generată grafic cu ajutorul pachetului Matplotlib \cite{Hunter:2007, PyCerealizer:2015}. De asemenea am folosit sistemul de versionare Git iar în prezent codul folosit este găzduit de GitHub \cite{Github:2015, CodeGit:2015}.

Având în vedere că articolul original nu menționează o metodă de padding, am considerat o metodă standard pentru a completa octeții ultimului bloc: alipim la sfârșitul lui $\mathcal{S}$ octeții $80$ $00$ $\dots$ $00$ $00$ până când lungimea ultimului bloc ajunge la $k$ octeți.

Menționăm această metoda doar pentru completitudine, aceasta neafectând rezultatele, care consideră doar secvențele de octeți din antet sau de la începutul fișierului.


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\subsubsection{Detectarea tipului de fișier}\hspace*{\fill} \\

Extindem analiza făcută în Secțiunea {\ref{subsec:file_type_detection}} asupra tipurilor de fișiere din Tabelul {\ref{table:sign}} pentru $k = 2$ și creștem valoarea indicelui $i$ până când 2 componente devin egale. Fie $f_l$ polinomul de gradul $1$ asociat primului bloc al fișierului aflat pe linia $l$. Analog $f_c$ polinomul de gradul $1$ asociat primului bloc al fișierului aflat pe coloana $c$.

Tabelul {\ref{table:k2} prezintă} valoarea maximă a nodul $i$ pentru care $f_l(i) \neq f_c(i)$. Valoarea $-1$ indică lipsă de coliziuni ale lui $f_c(x)$, $f_l(x)$ pentru $i$, $i = {1,2,\dots,255}$ ($\not\exists 1 \leq i \leq 255$ a.î. $f_l(i) = f_c(i)$)).

Deoarece pe diagonala principală toate componentele sunt identice pentru $k \leq 4$, poate fi ignorată. în Tabelul {\ref{table:k2}} observăm valoarea $0$ pentru perechea $(wav, zip)$ pentru că $f_{wav}(1) = f_{zip}(1) = 27$ (Tabelul \ref{table:sign}).



%-----------------------------------------------------
\begin{table}[b]
\begin{center}
\caption{Indicele maxim $i$ a.î. componentele primului bloc sa fie distincte($k=2$)}\label{tb:margins}
\label{table:k2}
\begin{tabular}{cccccccc}
Tip Fișier & doc & gif & pdf & png & rar & wav & zip \\\hline
  doc & - & 169 & 194 & 209 & 170 & 206 & 110\\
  gif & 169 & - & 133 & 137 & 75 & -1 & 133\\
  pdf & 194 & 133 & - & -1 & 115 & 151 & 133\\
  png & 209 & 137 & -1 & - & 229 & 147 & 195\\
  rar & 170 & 75 & 115 & 229 & - & -1 & 42\\
  wav & 206 & -1 & 151 & 147 & -1 & - & 0\\
  zip & 110 & 133 & 133 & 195 & 42 & 0 & -\\ \hline
\end{tabular}
\end{center}
\end{table}

Tabelele {\ref{table:k3} și \ref{table:k4}} prezintă rezultatele pentru $k = 3$ si $k = 4$. Pentru $k \geq 5$ este nevoie de un antet cu mai mult de $4$ octeți.

Considerăm metoda de distribuire descrisă exact ca în Tabelul {\ref{fig:alouneh_distribution}}, și anume nodul de stocare $i$ primește componenta $f(i)$.
Dacă un atacator preia controlul nodului cu valoarea $i$ acesta poate face distincția între tipul a $2$ fișiere partajate cu probabilitate $1$ dacă $i$ e mai mic decât valoarea afișată în tabel.

Spre exemplu, un adversar care obține accesul unui singur nod de stocare, iar partajarea a fost făcută pentru $k=2$ poate distinge cu probabilitate $1$ între un fișier $doc$ sau $pdf$ dacă $i \leq 194$. Deoarece $n > 194$ nu se întâmplă în practică, acest atac funcționează. Faptul că multe valori sunt ridicate și majoritatea sunt $-1$ (Tabelul \ref{table:k3}), indică un nivel scăzut de securitate al schemei. în cazul celor cu $-1$ un adversar va caștiga întotdeauna cu probabilitatea $1$, indiferent de indicele nodului de stocare pe care il obține.

Precizăm că acest atac funcționează doar dacă nodurile de stocare își păstrează indexul în cazul partajării repetate a.î. aplicația disponibilă pe partea de client calculează cele $n$ valori $f(i_1),\dots,f(i_2)$ pentru $i_1,\dots,i_n$ distincte și păstrează nodul $j$ asociat lui $i_j$.


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
\begin{table}[t]
\begin{center}
\caption{Indicele maxim $i$ a.î. componentele primului bloc sa fie distincte($k=3$)}\label{tb:margins}
\label{table:k3}
\begin{tabular}{cccccccc}
Tip Fișier & doc & gif & pdf & png & rar & wav & zip \\\hline
  doc & - & 63 & -1 & -1 & -1 & -1 & -1\\
  gif & 63 & - & -1 & -1 & -1 & -1 & -1\\
  pdf & -1 & -1 & - & 164 & -1 & 119 & -1\\
  png & -1 & -1 & 164 & - & 143 & 122 & 129\\
  rar & -1 & -1 & -1 & 143 & - & 143 & -1\\
  wav & -1 & -1 & 119 & 122 & 143 & - & 172\\
  zip & -1 & -1 & -1 & 129 & -1 & 172 & -\\ \hline
\end{tabular}
\end{center}
\bigskip
\end{table}

%-----------------------------------------------------
\begin{table}[t]
\begin{center}
\caption{Indicele maxim $i$ a.î. componentele primului bloc sa fie distincte($k=4$)}\label{tb:margins}
\label{table:k4}
\begin{tabular}{cccccccc}
Tip Fișier & doc & gif & pdf & png & rar & wav & zip \\\hline
  doc & - & -1 & 38 & 95 & 1 & 95 & 98\\
  gif & -1 & - & -1 & -1 & 167 & -1 & -1\\
  pdf & 38 & -1 & - & 12 & 11 & 119 & 70\\
  png & 95 & -1 & 12 & - & 243 & 95 & 148\\
  rar & 1 & 167 & 11 & 243 & - & -1 & 94\\
  wav & 95 & -1 & 119 & 95 & -1 & - & -1\\
  zip & 98 & -1 & 70 & 148 & 94 & -1 & -\\ \hline
\end{tabular}
\end{center}
\bigskip
\end{table}

\subsubsection{Detectarea de conținut} \hspace*{\fill} \\

Considerăm scenariul pentru detectarea conținutului unui fișier, demonstrând practic cum un adversar poate să facă diferența între $2$ componente stocate pe același nod aparțin unor documente similare. Atacul presupune accesul la un singur nod, indiferent de mărimea pragului $k$.


Pentru experiment am ales $3$ fișiere \textit{pdf} disponibile online la {\cite{Europass:2015}}:
\begin{itemize}
  \item Europass Curriculum Vitae - BG, Bulgaria;
  \item Europass Curriculum Vitae - DK, Dannemark;
  \item Europass Mobility - RO, Romania.
\end{itemize}

%-----------------------------------------------------

\begin{figure}[b!]
\begin{center}{}
\includegraphics[width=0.53\textwidth]{img/db1.png}    % The printed column width is 8.4 cm.
\caption{Nod 1: Graficul componentelor pentru primele 2000 de blocuri} 
\label{fig:db1}
\end{center}
\end{figure}

%-----------------------------------------------------


%-----------------------------------------------------
\begin{figure}[t!]
\begin{center}
\includegraphics[width=0.53\textwidth]{img/db2.png}    % The printed column width is 8.4 cm.
\caption{Nod 2: Graficul componentelor pentru primele 2000 de blocuri} 
\label{fig:db2}
\end{center}
\end{figure}
%-----------------------------------------------------

%-----------------------------------------------------
\begin{figure}[b!]
\begin{center}
\includegraphics[width=0.53\textwidth]{img/db3.png}    % The printed column width is 8.4 cm.
\caption{Nod 3: Graficul componentelor pentru primele 2000 de blocuri} 
\label{fig:db3}
\end{center}
\end{figure}
%-----------------------------------------------------

%----------------------------------------------------
\begin{figure}[t!]
\begin{center}
\includegraphics[width=0.53\textwidth]{img/db4.png}    % The printed column width is od8.4 cm.
\caption{Nod 4: Graficul componentelor pentru primele 2000 de blocuri} 
\label{fig:db4}
\end{center}
\end{figure}
%-----------------------------------------------------
%-----------------------------------------------------




Primele două fișiere reprezintă șablonul pentru un CV european în limba bulgară, respectiv daneză. Observăm că nu doar conținutul șabloanelor diferă, dar și limba în care au fost traduse. Cel de-al treilea fișier este complet diferit de primele două, fiind un document personal în limba română, folosit pentru înregistrarea cunoștiintelor dobăndite într-o țară europeană.

Pentru a arăta vulnerabilitatea sistemului Alouneh et al. {\cite{AAMK:2013}}, partajăm cele $3$ fișiere folosind schema $(2, 4)$. Experimentul reprezintă o implementare practică a metodei prezentate in Fig. {\ref{fig:alouneh_distribution}}.

Fig. {\ref{fig:db1}}, {\ref{fig:db2}}, {\ref{fig:db3}}, {\ref{fig:db4}} conțin $2000$ de componente generate pentru cele $3$ fișiere, stocate în baza de date corespunzătoare nodurilor $1,2,3$ și $4$. Presupunem că indicele $i$ este fixat, polinoamele fiind evaluate în același nod $i$. Un adversar care obține componentele unui nod poate deduce cu ușurinta graficul lor.

Considerăm că un adversar reușește să obțină componentele din Fig. {\ref{fig:db1}}. Poate deduce ușor că primele două fișiere au un număr mare de componente identice iar cel de-al $3$-lea este diferit de primele.

Din cauza șablonului pe care îl respectă cele două CV-uri, un adversar are nevoie în cazul de față doar de primele $500$ de componente pentru a constata similiaritatea celor $2$ cu o probabilitate ridicată.
Diferența vizuala este evidentă între oricare din cele $4$ grafice, deci un adversar poate reuși să afle informații despre fișierele partajate indiferent de nodul de stocare vulnerabil.

Considerăm în continuare un alt scenariu, în care partajăm o imagine pentru care informația se repetă. Fie imaginea din Fig. {\ref{fig:carouri}} partajată folosind schema din Secțiunea {\ref{sec:desc_alouneh}} având $4$ noduri iar informația stocată pe cel puțin $2$ din ele pot reconstitui imaginea partajată inițial. {\ref{fig:alouneh_distribution}}. La fel ca în exemplul precedent, Fig. {\ref{fig:carouri_db1}, \ref{fig:carouri_db2}, \ref{fig:carouri_db3}, \ref{fig:carouri_db4}} reprezintă grafic componente imaginii din Fig. {\ref{fig:carouri}}. Un adversar constată cu ușurință prin obținerea informațiilor stocate aflate pe un singur nod (indiferent de mărimea pragului $k$) că fișierul original conține un pattern care se repetă.


%-----------------------------------------------------
\begin{figure}[H]
\begin{center}
\includegraphics[width=0.35\textwidth]{img/carouri.png}    % The printed column width is 8.4 cm.
\caption{Imagine conținând pattern-uri} 
\label{fig:carouri}
\end{center}
\end{figure}
%-----------------------------------------------------


%-----------------------------------------------------
\begin{figure}[t!]
\begin{center}
\includegraphics[width=0.55\textwidth]{img/carouri_db1.png}    % The printed column width is 8.4 cm.
\caption{Nod 1: Graficul componentelor pentru primele 2000 de blocuri} 
\label{fig:carouri_db1}
\end{center}
\end{figure}
%-----------------------------------------------------

%-----------------------------------------------------
\begin{figure}[t!]
\begin{center}
\includegraphics[width=0.55\textwidth]{img/carouri_db2.png}    % The printed column width is 8.4 cm.
\caption{Nod 2: Graficul componentelor pentru primele 2000 de blocuri} 
\label{fig:carouri_db2}
\end{center}
\end{figure}
%-----------------------------------------------------

%-----------------------------------------------------
\begin{figure}[t!]
\begin{center}
\includegraphics[width=0.55\textwidth]{img/carouri_db3.png}    % The printed column width is 8.4 cm.
\caption{Nod 3: Graficul componentelor pentru primele 2000 de blocuri} 
\label{fig:carouri_db3}
\end{center}
\end{figure}
%-----------------------------------------------------

%-----------------------------------------------------
\begin{figure}[t!]
\begin{center}
\includegraphics[width=0.55\textwidth]{img/carouri_db4.png}    % The printed column width is 8.4 cm.
\caption{Nod 4: Graficul componentelor pentru primele 2000 de blocuri} 
\label{fig:carouri_db4}
\end{center}
\end{figure}
%-----------------------------------------------------


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------



\chapter{Implementare alternativă a sistemelor de stocare}
\label{cha:alternave-implementations}

%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
\section{Arhitectură bazată pe scheme de partajare}

%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
% poate tehnologii folosite?
\section{Instanțe Amazon EC2}

%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
\section{Reconstituirea fișierelor}


%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------

\clearpage

\bibliographystyle{splncs}
\bibliography{llncs}

\end{document}


